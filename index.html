<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>JBCave</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #222;
            font-family: Arial, sans-serif;
            overflow: hidden;
            touch-action: none; /* Prevent default touch behaviors */
        }
        #game-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            height: 100vh;
            max-height: 600px;
            background-color: #000;
            overflow: hidden; /* Keep content inside container */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #000;
        }
        #score-display {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #fff;
            font-size: 20px;
            z-index: 5;
        }
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            display: none;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            font-size: 24px;
            overflow-y: auto;
            padding: 20px 0;
            z-index: 10;
            box-sizing: border-box;
        }
        .menu-title {
            font-size: 42px;
            margin: 15px 0;
            color: #39c;
            text-shadow: 0 0 10px #39c;
        }
        .high-score {
            font-size: 18px;
            margin: 5px 0;
        }
        .controls-info {
            font-size: 14px;
            margin-bottom: 15px;
            text-align: center;
            max-width: 80%;
        }
        .settings-container {
            display: none;
            flex-direction: column;
            margin: 10px 0;
            width: 90%;
            max-width: 500px;
        }
        .slider-container {
            display: flex;
            flex-direction: column;
            width: 100%;
        }
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        .slider-value {
            width: 40px;
            text-align: right;
        }
        input[type="range"] {
            width: 100%;
            margin-bottom: 15px;
        }
        .button-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 10px 0;
        }
        button {
            margin: 8px 0;
            padding: 8px 16px;
            font-size: 16px;
            cursor: pointer;
            background-color: #39c;
            color: white;
            border: none;
            border-radius: 5px;
            transition: all 0.2s;
            min-width: 180px;
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
        }
        button:hover {
            background-color: #27a;
            transform: scale(1.05);
        }
        #start-btn {
            background-color: #4CAF50;
            font-size: 20px;
            padding: 12px 24px;
            min-width: 220px;
        }
        #start-btn:hover {
            background-color: #45a049;
        }
        .secondary-btn {
            background-color: #666;
            font-size: 16px;
        }
        .secondary-btn:hover {
            background-color: #555;
        }
        
        /* High Score CSS */
        #high-score-input {
            z-index: 20; /* Make sure it's on top */
        }

        #name-input-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
        }

        #name-input {
            padding: 8px;
            margin: 10px 0;
            font-size: 18px;
            width: 200px;
            text-align: center;
            display: none; /* Hidden by default */
        }

        .leaderboard-table {
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
            border-collapse: collapse;
        }

        .leaderboard-table th, .leaderboard-table td {
            padding: 6px;
            text-align: left;
            border-bottom: 1px solid #444;
            font-size: 14px;
        }

        .leaderboard-table th {
            background-color: #333;
            color: #39c;
        }

        .leaderboard-table tr:nth-child(even) {
            background-color: rgba(57, 153, 204, 0.1);
        }

        .leaderboard-table tr:hover {
            background-color: rgba(57, 153, 204, 0.2);
        }

        .loading {
            margin: 10px;
            font-style: italic;
            color: #999;
            font-size: 14px;
        }

        #leaderboard-container {
            width: 90%;
            max-width: 600px;
            margin: 10px 0;
            padding: 5px;
        }
        
        #leaderboard-container h3 {
            text-align: center;
            color: #39c;
            margin: 10px 0;
            font-size: 18px;
        }
        
        .leaderboard-tabs {
            display: flex;
            justify-content: center;
            margin: 10px 0;
        }
        
        .tab-button {
            padding: 5px 10px;
            margin: 0 5px;
            background-color: #333;
            border: 1px solid #555;
            color: #ccc;
            cursor: pointer;
            font-size: 14px;
            border-radius: 3px;
        }
        
        .tab-button.active {
            background-color: #39c;
            color: white;
        }
        
        .leaderboard-content {
            margin: 10px 0;
        }
        
        /* Mobile Optimization */
        @media (max-width: 800px) {
            body {
                align-items: flex-start; /* Better positioning on mobile */
            }
            
            #game-container {
                height: 100vh;
                width: 100%;
                max-width: none;
                max-height: none;
            }
            
            canvas {
                width: 100%;
                height: 100%;
            }
            
            button {
                padding: 12px 24px; /* Larger touch targets */
                min-width: 200px;
                margin: 10px 0;
            }
            
            .menu-title {
                font-size: 36px;
                margin-top: 30px;
            }
            
            .overlay {
                padding: 10px;
                justify-content: flex-start;
            }
        }
        
        /* Landscape mode specific styles */
        @media (max-width: 800px) and (orientation: landscape) {
            #game-container {
                height: 100vh;
            }
            
            .overlay {
                padding: 5px;
            }
            
            .menu-title {
                font-size: 28px;
                margin: 5px 0;
            }
            
            .button-container {
                margin: 5px 0;
            }
            
            button {
                padding: 8px 16px;
                margin: 5px 0;
                font-size: 14px;
            }
            
            .controls-info {
                font-size: 12px;
                margin-bottom: 5px;
            }
            
            #leaderboard-container {
                margin: 5px 0;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="score-display">Score: 0</div>
        <div id="game-over" class="overlay">
            <h2>Game Over!</h2>
            <p id="final-score">Your score: 0</p>
            <p id="high-score-display">High score: 0</p>
            <p class="controls-info">Press SPACE, UP, or tap to play again</p>
            <div class="button-container">
                <button id="restart-btn">Play Again</button>
                <button id="menu-btn" class="secondary-btn">Back to Menu</button>
            </div>
        </div>
        <div id="start-menu" class="overlay">
            <h1 class="menu-title">JBCave</h1>
            <p class="high-score main-menu-item" id="menu-high-score">High Score: 0</p>
            <p class="controls-info main-menu-item">
                Use SPACE, UP arrow, or tap to fly up.<br>
                Release to fall down.<br>
                Avoid the cave walls and obstacles!
            </p>
            
            <!-- Leaderboard Section with Tabs -->
            <div id="leaderboard-container" class="main-menu-item">
                <h3>Leaderboard</h3>
                <div class="leaderboard-tabs">
                    <button id="personal-tab" class="tab-button active" onclick="switchLeaderboardTab('personal')">My Scores</button>
                    <button id="global-tab" class="tab-button" onclick="switchLeaderboardTab('global')">Global Scores</button>
                </div>
                <div id="personal-leaderboard" class="leaderboard-content"></div>
                <div id="global-leaderboard" class="leaderboard-content" style="display:none;"></div>
            </div>
            
            <div class="settings-container" id="settings-panel">
                <h3>Game Settings</h3>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Gravity:</span>
                        <span class="slider-value" id="gravity-value">0.25</span>
                    </div>
                    <input type="range" id="gravity-slider" min="0.15" max="0.5" step="0.01" value="0.25">
                    
                    <div class="slider-label">
                        <span>Lift Strength:</span>
                        <span class="slider-value" id="lift-value">0.45</span>
                    </div>
                    <input type="range" id="lift-slider" min="0.3" max="0.8" step="0.01" value="0.45">
                    
                    <div class="slider-label">
                        <span>Max Speed:</span>
                        <span class="slider-value" id="speed-value">6.0</span>
                    </div>
                    <input type="range" id="speed-slider" min="4" max="10" step="0.5" value="6">
                    
                    <div class="slider-label">
                        <span>Obstacle Frequency:</span>
                        <span class="slider-value" id="obstacle-value">150</span>
                    </div>
                    <input type="range" id="obstacle-slider" min="80" max="250" step="10" value="150">
                </div>
                
                <!-- Settings back button -->
                <button id="settings-back-btn" class="secondary-btn">Back to Menu</button>
            </div>
            
            <div class="button-container main-menu-item">
                <button id="start-btn">Start Game</button>
                <button id="settings-btn" class="secondary-btn">Game Settings</button>
            </div>
        </div>
        
        <!-- High Score Input Form -->
        <div id="high-score-input" class="overlay">
            <h2>New High Score!</h2>
            <p id="high-score-value">Your score: 0</p>
            
            <div id="name-input-container">
                <button id="activate-input-btn">Tap to Enter Your Name</button>
                <input type="text" id="name-input" maxlength="20" placeholder="Your name">
            </div>
            
            <div class="button-container">
                <button id="submit-score-btn">Submit Score</button>
                <button id="skip-submit-btn" class="secondary-btn">Skip</button>
            </div>
        </div>
    </div>

    <script>
        // Get DOM elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreDisplay = document.getElementById('final-score');
        const restartBtn = document.getElementById('restart-btn');
        const startBtn = document.getElementById('start-btn');
        
        // Timing variables for consistent game speed
        let lastTime = 0;
        let deltaTime = 0;
        const TARGET_FPS = 60;
        const TIME_STEP = 1000 / TARGET_FPS;
        
        // Resize canvas to fit container
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        
        // Call resize on load and window resize
        window.addEventListener('load', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);
        
        // Game variables
        let score = 0;
        let gameSpeed = 3;
        let gravity = 0.25;
        let lift = -0.45;
        let maxVelocity = 6;
        let isGameOver = false;
        let isThrusting = false;
        let caveSections = [];
        let obstacles = [];
        let lastCaveY = 0;
        let difficultyIncreaseInterval = 100;
        let obstacleTimer = 0;
        let highScore = 0;
        let gameState = "menu";
        let restartDelay = 0;
        
        // Particle system for explosions
        let particles = [];
        const PARTICLE_COUNT = 50;
        const PARTICLE_GRAVITY = 0.1;
        const PARTICLE_FRICTION = 0.98;
        const PARTICLE_LIFESPAN = 60; // frames
        
        // High score variables
        let globalHighScores = [];
        let apiBaseUrl = '/jbcave';
        let lastSubmittedScore = 0;
        
        // Player variables
        const player = {
            x: 150,
            y: 0, // Will be set based on canvas height
            width: 6,
            height: 6,
            velocity: 0,
            trailPositions: [],
            trailLength: 50
        };

        // Cave generation parameters
        const caveParams = {
            minHeight: 100,
            maxHeight: 200,
            initialGap: 300,
            minGap: 100,
            narrowingRate: 0.1,
            sectionWidth: 50,
            roughness: 0.5,
            obstacleFrequency: 150,
            obstacleWidth: 15,      
            obstacleHeight: 50,     
            maxObstacles: 5,        
            caveMinWidth: 3000
        };
        
        // Event for handling input state
        function handleInput(isPressed) {
            isThrusting = isPressed;
        }
        
        // Variables to track input state
        let keyIsDown = false;
        let touchIsActive = false;
        
        // Create explosion particles when player crashes
        function createExplosion(x, y) {
            particles = [];
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 5;
                const size = 2 + Math.random() * 4;
                const color = `hsl(${Math.random() * 30 + 200}, 100%, 60%)`;
                
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: size,
                    color: color,
                    alpha: 1,
                    life: PARTICLE_LIFESPAN
                });
            }
        }
        
        // Update particle positions and properties
        function updateParticles(deltaFactor) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                
                // Apply gravity and friction
                p.vy += PARTICLE_GRAVITY * deltaFactor;
                p.vx *= PARTICLE_FRICTION;
                p.vy *= PARTICLE_FRICTION;
                
                // Update position
                p.x += p.vx * deltaFactor;
                p.y += p.vy * deltaFactor;
                
                // Update life and alpha
                p.life--;
                p.alpha = p.life / PARTICLE_LIFESPAN;
                
                // Remove dead particles
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        // Draw particles
        function drawParticles() {
            for (const p of particles) {
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
        
        // Initialize the game
        function init() {
            // Reset game variables
            score = 0;
            gameSpeed = 3;
            caveSections = [];
            obstacles = [];
            obstacleTimer = 0;
            particles = [];
            
            // Get values from sliders if game was started from menu
            if (gameState === "menu") {
                gravity = parseFloat(document.getElementById("gravity-slider").value);
                lift = -parseFloat(document.getElementById("lift-slider").value);
                maxVelocity = parseFloat(document.getElementById("speed-slider").value);
                caveParams.obstacleFrequency = parseInt(document.getElementById("obstacle-slider").value);
            }
            
            // Center player vertically
            player.y = canvas.height / 2;
            player.velocity = 0;
            player.trailPositions = [];
            
            // Generate initial cave
            initializeCave();
            
            // Hide menus
            document.getElementById("start-menu").style.display = "none";
            document.getElementById("game-over").style.display = "none";
            document.getElementById("high-score-input").style.display = "none";
            document.getElementById("score-display").style.display = "block";
            
            // Set game state
            gameState = "playing";
            isGameOver = false;
            
            // Start game loop if not already running
            if (!window.gameLoopRunning) {
                window.gameLoopRunning = true;
                requestAnimationFrame(gameLoop);
            }
        }
        
        // Generate the initial cave structure
        function initializeCave() {
            // Start with middle of the screen
            lastCaveY = canvas.height / 2;
            
            // Create enough sections to fill the screen plus some extra
            for (let x = 0; x < canvas.width + 400; x += caveParams.sectionWidth) {
                generateNextCaveSection(x);
            }
        }
        
        // Generate a new cave section
        function generateNextCaveSection(x) {
            // Calculate the current gap size based on score
            let currentGap = caveParams.initialGap;
            
            // Scale gap based on canvas height for mobile
            const scaleRatio = canvas.height / 500;
            currentGap = currentGap * scaleRatio;
            
            // Only narrow the cave until a certain score
            if (score < caveParams.caveMinWidth) {
                currentGap = Math.max(
                    caveParams.minGap * scaleRatio, 
                    currentGap - (score / difficultyIncreaseInterval * caveParams.narrowingRate * 10 * scaleRatio)
                );
            }
            
            // Create more pronounced meandering as the game progresses
            let meanderStrength = Math.min(40 * scaleRatio, score / 100);
            
            // Create randomness based on previous position
            const randomShift = (Math.random() * 2 - 1) * caveParams.roughness * meanderStrength;
            
            // Ensure the cave stays within the canvas bounds with some margin
            const margin = 50 * scaleRatio;
            const minY = margin + currentGap / 2;
            const maxY = canvas.height - margin - currentGap / 2;
            
            // Calculate new Y position with constraints
            let newY = lastCaveY + randomShift;
            newY = Math.max(minY, Math.min(newY, maxY));
            
            // Create the base cave section
            const section = {
                x: x,
                centerY: newY,
                gapHeight: currentGap
            };
            
            // Add to cave sections
            caveSections.push(section);
            
            // Update for next section
            lastCaveY = newY;
        }
        
        // Create a new obstacle
        function createObstacle() {
            if (obstacles.length >= caveParams.maxObstacles) return;
            
            // Find the last cave section
            const availableSections = caveSections.filter(s => s.x >= canvas.width);
            if (availableSections.length === 0) return;
            
            // Use a section that's just off-screen
            const section = availableSections[0];
            
            // Add slight random offset to obstacle position
            const offset = (Math.random() * 0.4 - 0.2) * section.gapHeight; 
            
            // Scale obstacle size based on canvas height
            const scaleRatio = canvas.height / 500;
            const obstacleHeight = caveParams.obstacleHeight * scaleRatio;
            const obstacleWidth = caveParams.obstacleWidth * scaleRatio;
            
            // Only create obstacle if there's enough space in the cave
            if (section.gapHeight > obstacleHeight * 1.5) {
                obstacles.push({
                    x: section.x,
                    y: section.centerY + offset - (obstacleHeight / 2),
                    width: obstacleWidth,
                    height: obstacleHeight
                });
            }
        }
        
        // Update game state
        function update(deltaFactor) {
            // If in menu state, do nothing
            if (gameState === "menu") {
                return;
            }
            
            // If game over, just update restart delay counter and particles
            if (gameState === "gameover") {
                restartDelay++;
                updateParticles(deltaFactor);
                return;
            }
            
            // Update player velocity based on input
            if (isThrusting) {
                player.velocity += lift * deltaFactor;
            } else {
                player.velocity += gravity * deltaFactor;
            }
            
            // Limit max velocity
            player.velocity = Math.max(-maxVelocity, Math.min(player.velocity, maxVelocity));
            
            // Update player position
            player.y += player.velocity * deltaFactor;
            
            // Add current position to trail
            player.trailPositions.unshift({x: player.x, y: player.y});
            
            // Update all previous trail positions by moving them left with game speed
            for (let i = 1; i < player.trailPositions.length; i++) {
                player.trailPositions[i].x -= gameSpeed * deltaFactor;
            }
            
            // Limit trail length
            if (player.trailPositions.length > player.trailLength || 
                (player.trailPositions.length > 0 && 
                player.trailPositions[player.trailPositions.length-1].x < -50)) {
                player.trailPositions.pop();
            }
            
            // Move cave sections
            for (let i = 0; i < caveSections.length; i++) {
                caveSections[i].x -= gameSpeed * deltaFactor;
            }
            
            // Move obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].x -= gameSpeed * deltaFactor;
                
                // Remove obstacles that are off-screen
                if (obstacles[i].x + obstacles[i].width < 0) {
                    obstacles.splice(i, 1);
                }
            }
            
            // Remove off-screen sections and generate new ones
            if (caveSections[0].x <= -caveParams.sectionWidth) {
                caveSections.shift();
                
                // Figure out what x value to use for the new section
                const lastSectionX = caveSections[caveSections.length - 1].x;
                generateNextCaveSection(lastSectionX + caveParams.sectionWidth);
            }
            
            // Handle obstacle generation timing
            obstacleTimer += deltaFactor;
            const obstacleInterval = Math.max(80, caveParams.obstacleFrequency - Math.floor(score / 1000) * 10);
            
            if (obstacleTimer >= obstacleInterval && score > 300) {
                createObstacle();
                obstacleTimer = 0;
            }
            
            // Check for collisions
            checkCollisions();
            
            // Update score based on time rather than frames
            score += deltaFactor * 0.6;
            scoreDisplay.textContent = `Score: ${Math.floor(score)}`;
            
            // Increase difficulty gradually
            if (Math.floor(score) % difficultyIncreaseInterval === 0 && 
                Math.floor(score) > 0 && 
                Math.floor(score - deltaFactor) % difficultyIncreaseInterval !== 0) {
                
                // Increase speed up to a certain point
                if (gameSpeed < 7) {
                    gameSpeed += 0.1;
                }
            }
            
            // Update any active particles
            updateParticles(deltaFactor);
        }
        
        // Check collisions with cave walls and obstacles
        function checkCollisions() {
            // Get player current position (front of the ribbon)
            const playerX = player.x;
            const playerY = player.y;
            const playerRadius = player.height / 2;
            
            // Find the cave sections that the player is currently passing through
            for (const section of caveSections) {
                if (playerX + playerRadius >= section.x && 
                    playerX - playerRadius <= section.x + caveParams.sectionWidth) {
                    
                    // Check if player hits top or bottom wall
                    const topWallBottom = section.centerY - (section.gapHeight / 2);
                    const bottomWallTop = section.centerY + (section.gapHeight / 2);
                    
                    if (playerY - playerRadius <= topWallBottom || 
                        playerY + playerRadius >= bottomWallTop) {
                        createExplosion(playerX, playerY);
                        gameOver();
                        return;
                    }
                }
            }
            
            // Check for collision with obstacles
            for (const obstacle of obstacles) {
                if (playerX + playerRadius >= obstacle.x && 
                    playerX - playerRadius <= obstacle.x + obstacle.width && 
                    playerY + playerRadius >= obstacle.y && 
                    playerY - playerRadius <= obstacle.y + obstacle.height) {
                    createExplosion(playerX, playerY);
                    gameOver();
                    return;
                }
            }
            
            // Check if player hits the canvas edges
            if (playerY - playerRadius <= 0 || 
                playerY + playerRadius >= canvas.height) {
                createExplosion(playerX, playerY);
                gameOver();
            }
        }
        
        // Game over
        function gameOver() {
            isGameOver = true;
            gameState = "gameover";
            score = Math.floor(score); // Round the final score down to an integer
            
            // Update high score if needed
            if (score > highScore) {
                highScore = score;
                // Try to save high score to localStorage
                try {
                    localStorage.setItem('jbcave-highscore', highScore.toString());
                    document.getElementById('menu-high-score').textContent = `High Score: ${highScore}`;
                } catch (e) {
                    console.log('Could not save high score');
                }
            }
            
            // Save personal scores to localStorage
            try {
                let personalScores = JSON.parse(localStorage.getItem('jbcave-scores') || '[]');
                personalScores.push(Math.floor(score)); // Ensure it's an integer
                personalScores.sort((a, b) => b - a); // Sort in descending order
                if (personalScores.length > 10) personalScores = personalScores.slice(0, 10); // Keep top 10
                localStorage.setItem('jbcave-scores', JSON.stringify(personalScores));
            } catch (e) {
                console.log('Could not save personal scores');
            }
            
            // Always prompt for name to submit score if over 100
            if (score > 100 && score !== lastSubmittedScore) {
                // Show high score input after a short delay to see explosion
                setTimeout(() => {
                    document.getElementById('high-score-value').textContent = `Your score: ${score}`;
                    document.getElementById('high-score-input').style.display = 'flex';
                    document.getElementById('name-input').style.display = 'none';
                    document.getElementById('activate-input-btn').style.display = 'block';
                }, 1000);
                return; // Don't show game over screen yet
            }
            
            // Show game over screen
            finalScoreDisplay.textContent = `Your score: ${score}`;
            document.getElementById("high-score-display").textContent = `High score: ${highScore}`;
            gameOverScreen.style.display = 'flex';
            
            // Reset restart delay
            restartDelay = 0;
        }
        
        // Draw game elements
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Only draw the game itself if not in menu state
            if (gameState !== "menu") {
                // Draw cave
                drawCave();
                
                // Draw obstacles
                drawObstacles();
                
                // Draw player trail (which is now the only visual for the player)
                drawPlayerTrail();
                
                // Draw particles
                drawParticles();
            }
        }
        
        // Draw the cave walls
        function drawCave() {
            // Draw upper and lower walls with meandering path as score increases
            for (const section of caveSections) {
                if (section.x > canvas.width) continue;
                
                ctx.fillStyle = '#282';
                
                // Top wall
                ctx.fillRect(
                    section.x, 
                    0, 
                    caveParams.sectionWidth, 
                    section.centerY - (section.gapHeight / 2)
                );
                
                // Bottom wall
                ctx.fillRect(
                    section.x, 
                    section.centerY + (section.gapHeight / 2), 
                    caveParams.sectionWidth, 
                    canvas.height - (section.centerY + (section.gapHeight / 2))
                );
            }
        }
        
        // Draw obstacles
        function drawObstacles() {
            for (const obstacle of obstacles) {
                // Draw the obstacle with a bright color and border
                ctx.fillStyle = '#f44';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            }
        }
        
        // Draw player's trail as a flowing ribbon
        function drawPlayerTrail() {
            if (player.trailPositions.length < 2) return;
            
            ctx.strokeStyle = '#39c';
            ctx.lineWidth = player.height;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            ctx.beginPath();
            ctx.moveTo(player.trailPositions[0].x, player.trailPositions[0].y);
            
            for (let i = 1; i < player.trailPositions.length; i++) {
                ctx.lineTo(player.trailPositions[i].x, player.trailPositions[i].y);
            }
            
            ctx.stroke();
        }
        
        // High Score Functions
        
        // Display personal scores from localStorage
        function displayPersonalScores() {
            try {
                const personalScores = JSON.parse(localStorage.getItem('jbcave-scores') || '[]');
                const leaderboardEl = document.getElementById('personal-leaderboard');
                
                if (personalScores.length === 0) {
                    leaderboardEl.innerHTML = '<div class="loading">No personal scores yet</div>';
                    return;
                }
                
                let tableHtml = `
                    <table class="leaderboard-table">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Score</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                personalScores.slice(0, 5).forEach((score, index) => {
                    tableHtml += `
                        <tr>
                            <td>${index + 1}</td>
                            <td>${score}</td>
                        </tr>
                    `;
                });
                
                tableHtml += `
                        </tbody>
                    </table>
                `;
                
                leaderboardEl.innerHTML = tableHtml;
            } catch (e) {
                console.log('Could not display personal scores', e);
            }
        }
        
        // Display global high scores
        function displayGlobalHighScores() {
            const leaderboardEl = document.getElementById('global-leaderboard');
            
            if (globalHighScores.length === 0) {
                leaderboardEl.innerHTML = '<div class="loading">No global scores yet. Be the first!</div>';
                return;
            }
            
            let tableHtml = `
                <table class="leaderboard-table">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Name</th>
                            <th>Score</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            globalHighScores.slice(0, 5).forEach((scoreData, index) => {
                tableHtml += `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${scoreData.player_name}</td>
                        <td>${scoreData.score}</td>
                    </tr>
                `;
            });
            
            tableHtml += `
                    </tbody>
                </table>
            `;
            
            leaderboardEl.innerHTML = tableHtml;
        }
        
        // Switch between personal and global leaderboard tabs
        function switchLeaderboardTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`${tabName}-tab`).classList.add('active');
            
            // Show the selected leaderboard
            document.querySelectorAll('.leaderboard-content').forEach(content => {
                content.style.display = 'none';
            });
            document.getElementById(`${tabName}-leaderboard`).style.display = 'block';
        }
        
        // Fetch high scores from the server
        function fetchHighScores() {
            // Display personal scores
            displayPersonalScores();
            
            // Fetch global scores
            const leaderboardEl = document.getElementById('global-leaderboard');
            leaderboardEl.innerHTML = '<div class="loading">Loading scores...</div>';
            
            fetch(`${apiBaseUrl}/get_scores.php?limit=10`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success && data.scores) {
                        globalHighScores = data.scores;
                        displayGlobalHighScores();
                    } else {
                        throw new Error('Invalid data format');
                    }
                })
                .catch(error => {
                    console.error('Error fetching high scores:', error);
                    leaderboardEl.innerHTML = '<div class="loading">Could not load scores</div>';
                });
        }
        
        // Submit a high score to the server
        function submitHighScore() {
            const nameInput = document.getElementById('name-input');
            const playerName = nameInput.value.trim();
            
            if (!playerName) {
                alert('Please enter your name!');
                return;
            }
            
            // Disable the submit button to prevent double submission
            document.getElementById('submit-score-btn').disabled = true;
            
            fetch(`${apiBaseUrl}/submit_score.php`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    name: playerName,
                    score: score
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    // Record that we've submitted this score
                    lastSubmittedScore = score;
                    
                    // Hide high score input
                    document.getElementById('high-score-input').style.display = 'none';
                    
                    // Show game over screen
                    finalScoreDisplay.textContent = `Your score: ${score}`;
                    document.getElementById("high-score-display").textContent = `High score: ${highScore}`;
                    gameOverScreen.style.display = 'flex';
                    
                    // Refresh high scores in the background
                    fetchHighScores();
                } else {
                    throw new Error('Score submission failed');
                }
            })
            .catch(error => {
                console.error('Error submitting score:', error);
                alert('Could not submit your score. Please try again.');
                
                // Re-enable the submit button
                document.getElementById('submit-score-btn').disabled = false;
            });
        }
        
        // Game loop with consistent timing
        function gameLoop(timestamp) {
            // Calculate delta time
            if (!lastTime) {
                lastTime = timestamp;
            }
            
            deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            // Calculate the factor to scale movements by
            // This ensures consistent speed regardless of frame rate
            const deltaFactor = deltaTime / TIME_STEP;
            
            update(deltaFactor);
            draw();
            
            // Continue game loop
            requestAnimationFrame(gameLoop);
        }
        
        // Show main menu
        function showMainMenu() {
            gameState = "menu";
            document.getElementById('start-menu').style.display = 'flex';
            document.getElementById('score-display').style.display = 'none';
            document.getElementById('high-score-input').style.display = 'none';
            document.getElementById('menu-high-score').textContent = `High Score: ${highScore}`;
            
            // Show all main menu items and hide settings
            document.querySelectorAll('.main-menu-item').forEach(item => {
                item.style.display = '';
            });
            document.getElementById('settings-panel').style.display = 'none';
            document.getElementById('settings-btn').textContent = 'Game Settings';
            
            // Fetch current high scores
            fetchHighScores();
            
            // Reset game elements
            caveSections = [];
            obstacles = [];
            particles = [];
            player.trailPositions = [];
        }
        
        // Toggle settings panel visibility
        function toggleSettings() {
            const settingsPanel = document.getElementById('settings-panel');
            const mainMenuItems = document.querySelectorAll('.main-menu-item');
            
            if (settingsPanel.style.display === 'flex') {
                // Show main menu items
                mainMenuItems.forEach(item => {
                    item.style.display = '';
                });
                settingsPanel.style.display = 'none';
                document.getElementById('settings-btn').textContent = 'Game Settings';
            } else {
                // Hide main menu items
                mainMenuItems.forEach(item => {
                    item.style.display = 'none';
                });
                settingsPanel.style.display = 'flex';
                document.getElementById('settings-btn').textContent = 'Game Settings';
            }
        }
        
        // Setup High Score Event Listeners
        function setupHighScoreEventListeners() {
            // Activate input button (to prevent keyboard from popping up automatically)
            document.getElementById('activate-input-btn').addEventListener('click', function() {
                this.style.display = 'none';
                document.getElementById('name-input').style.display = 'block';
                document.getElementById('name-input').focus();
            });
            
            // Submit score button
            document.getElementById('submit-score-btn').addEventListener('click', submitHighScore);
            
            // Skip submit button
            document.getElementById('skip-submit-btn').addEventListener('click', () => {
                document.getElementById('high-score-input').style.display = 'none';
                
                // Show game over screen
                finalScoreDisplay.textContent = `Your score: ${score}`;
                document.getElementById("high-score-display").textContent = `High score: ${highScore}`;
                gameOverScreen.style.display = 'flex';
            });
            
            // Allow Enter key to submit score when input is focused
            document.getElementById('name-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    submitHighScore();
                }
            });
            
            // Settings back button
            document.getElementById('settings-back-btn').addEventListener('click', toggleSettings);
        }
        
        // Handle user input events
        function setupEventListeners() {
            // Touch events for the game (mobile)
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent scrolling
                touchIsActive = true;
                handleInput(true);
            });
            
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchIsActive = false;
                handleInput(false);
            });
            
            canvas.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                touchIsActive = false;
                handleInput(false);
            });
            
            // Mouse events (desktop)
            canvas.addEventListener('mousedown', () => {
                if (!touchIsActive) handleInput(true);
            });
            
            canvas.addEventListener('mouseup', () => {
                if (!touchIsActive) handleInput(false);
            });
            
            canvas.addEventListener('mouseleave', () => {
                if (!touchIsActive) handleInput(false);
            });
            
            // Key events
            window.addEventListener('keydown', (e) => {
                if ((e.key === ' ' || e.key === 'ArrowUp')) {
                    // Prevent scrolling when using space/arrow keys
                    e.preventDefault();
                    
                    // For gameplay
                    if (gameState === "playing" && !keyIsDown) {
                        keyIsDown = true;
                        handleInput(true);
                    }
                    // For game restart with delay
                    else if (gameState === "gameover" && restartDelay >= 30) {
                        gameOverScreen.style.display = 'none';
                        init();
                    }
                    // For game start from menu
                    else if (gameState === "menu") {
                        init();
                    }
                }
                
                // Allow Enter key to restart game
                if (e.key === 'Enter' && gameState === "gameover") {
                    gameOverScreen.style.display = 'none';
                    init();
                }
            });
            
            window.addEventListener('keyup', (e) => {
                if (e.key === ' ' || e.key === 'ArrowUp') {
                    keyIsDown = false;
                    handleInput(false);
                }
            });
            
            // Prevent keyboard repeat issues
            window.addEventListener('blur', () => {
                keyIsDown = false;
                handleInput(false);
            });
            
            // Game over screen buttons
            document.getElementById('restart-btn').addEventListener('click', () => {
                gameOverScreen.style.display = 'none';
                init();
            });
            
            document.getElementById('menu-btn').addEventListener('click', () => {
                gameOverScreen.style.display = 'none';
                showMainMenu();
            });
            
            // Main menu buttons
            document.getElementById('start-btn').addEventListener('click', () => {
                init();
            });
            
            document.getElementById('settings-btn').addEventListener('click', toggleSettings);
            
            // Slider event listeners
            document.getElementById('gravity-slider').addEventListener('input', (e) => {
                document.getElementById('gravity-value').textContent = e.target.value;
            });
            
            document.getElementById('lift-slider').addEventListener('input', (e) => {
                document.getElementById('lift-value').textContent = e.target.value;
            });
            
            document.getElementById('speed-slider').addEventListener('input', (e) => {
                document.getElementById('speed-value').textContent = e.target.value;
            });
            
            document.getElementById('obstacle-slider').addEventListener('input', (e) => {
                document.getElementById('obstacle-value').textContent = e.target.value;
            });
            
            // Setup high score event listeners
            setupHighScoreEventListeners();
            
            // Tab switching for leaderboards
            document.getElementById('personal-tab').addEventListener('click', () => switchLeaderboardTab('personal'));
            document.getElementById('global-tab').addEventListener('click', () => switchLeaderboardTab('global'));
            
            // Prevent default touch behavior for the entire game container
            document.getElementById('game-container').addEventListener('touchmove', (e) => {
                e.preventDefault();
            }, { passive: false });
        }
        
        // Initialize the application
        function initApp() {
            // Try to load high score from localStorage
            try {
                const savedHighScore = localStorage.getItem('jbcave-highscore');
                if (savedHighScore) {
                    highScore = parseInt(savedHighScore);
                }
            } catch (e) {
                console.log('Could not load high score');
            }
            
            // Update high score displays
            document.getElementById('menu-high-score').textContent = `High Score: ${highScore}`;
            
            // Set initial game state
            gameState = "menu";
            
            // Fix for the black screen on initial load
            document.getElementById('start-menu').style.display = 'flex';
            
            // Make sure score display is hidden initially
            document.getElementById('score-display').style.display = 'none';
            
            // Hide settings panel initially
            document.getElementById('settings-panel').style.display = 'none';
            
            // Setup all event listeners
            setupEventListeners();
            
            // Fetch high scores
            fetchHighScores();
            
            // Start game loop
            window.gameLoopRunning = true;
            requestAnimationFrame(gameLoop);
        }
        
        // Start the application when window loads
        window.addEventListener('load', initApp);
    </script>
</body>
</html>
